#pragma config(Sensor, S1,     	SonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     	ColorSensor,    sensorColorNxtFULL)
#pragma config(Sensor, S3,     	sensorLeft,     sensorLightActive)
#pragma config(Motor,  motorB,	RightMotor,    	tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,  LeftMotor,     	tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(NXT)
// Define app variables to send signals over bluetooth to the robot.
long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;
const int kMaxSizeOfMessage = 30;
const int INBOX = 5;
// function declarations
void forward(int speed);
void RGBValue(string sColor);
void searchLine(int speed, string sColor);
void slowDownStop();
void stopObstacle();
// variable definitions
const int default_speed = 13;
int speed = default_speed;
bool stop = true;
// Assign a string to every Color
void RGBValue(string &sColor) {
	  while (true) {
	    switch (SensorValue[ColorSensor])
	    {
	      case BLACKCOLOR:    sColor = "Black";     		return;
	      case WHITECOLOR:    sColor = "White";     		return;
	      default:            sColor = "Other Color";   return;
			}
		}
}
// Slow down function so the robot does not stop abruptly
void slowDownStop() {
	for(int i = speed; i > 0; i--) {
		speed--;
		motor[LeftMotor] = speed;
		motor[RightMotor] = speed;
		wait1Msec(100);
	}
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	speed = 0;
	stop = true;
	return;
}
// Slows down and stops in a smooth manner when obstacle is detected
void stopObstacle() {
	if (speed > 0 && stop==false) {
		if(SensorValue(SonarSensor) < 24)
		{
			 slowDownStop();
		}
	}
	return;
}
// function to drive the robot forwards, only gets called if both sensors detect white.
void forward (int speed) {
	motor[RightMotor] = speed;
	motor[LeftMotor] = speed;
	stop = false;
	return;
}
// function to go left or right depending on which of the 2 sensor detects a black line.
void searchLine(int speed, string sColor) {
	while (true) {
		stopObstacle();  // Stop slowly for obstacle
		RGBValue(sColor);
		if 	(SensorValue(sensorLeft) <= 45){
			motor[RightMotor] = 30;
			motor[LeftMotor] = 10;
		}
		if (sColor == "Black"){
			motor[LeftMotor] = 30;
			motor[RightMotor] = 10;
		}
		if (SensorValue(sensorLeft) > 45 && (sColor != "Black")) {
			return;
		}
	}
}
task main()
{
	// Define variables for the mobile app
	TFileIOResult nBTCmdRdErrorStatus;
	int nSizeOfMessage;
	ubyte nRcvBuffer[kMaxSizeOfMessage];
	string s = "";
	while (true)
	{
		nxtDisplayCenteredTextLine(1, "Sonar: %d", SensorValue[SonarSensor]);  // display Sensor Value
		//wait1Msec(100);  // Wait 100 milliseconds to help display correctly
		stopObstacle();  // Stop slowly for obstacle
		// The robot receives a string that the robot will desplay.
		nSizeOfMessage = cCmdMessageGetSize(INBOX);
		string sColor;
		if (stop == false) {
			forward(speed);
			RGBValue(sColor);
			if (SensorValue(sensorLeft) <= 45 || sColor == "Black") {
				searchLine(speed, sColor);
			}
		}
		if (nSizeOfMessage > kMaxSizeOfMessage){
			nSizeOfMessage = kMaxSizeOfMessage;
		}
		if (nSizeOfMessage > 0){
			nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
			nRcvBuffer[nSizeOfMessage] = '\0';
			stringFromChars(s, (char *) nRcvBuffer);
			displayCenteredBigTextLine(4, s);
			if(s == "UP"){ 												// If received string equals "UP" move robot forward.
				motor[LeftMotor] = 30;
				motor[RightMotor] = 30;							// Turn on both motors with 50% power.
			}//---------------------------------------------------------------------------------------------------------------------------
			else if(s == "DOWN"){									// If received string equals "DOWN" move robot backwards.
				motor[LeftMotor] = -30;
				motor[RightMotor] = -30;						// Both motors turn on with 50% power in opposite direction.
			}//-----------------------------------------------------------------------------------------------------------------------
			else if(s == "LEFT"){									// If received string equals "LEFT" turn robot to the left.
				motor[LeftMotor] = -23;
				motor[RightMotor] = 23;							// Left motor moves backwards while right motor moves forward at 23% power.
				wait1Msec(800);											// The robot has to turn for a total of 800 miliseconds.
				s = "C";														// Reset string to "C" to stop the robot
			}//---------------------------------------------------------------------------------------------------------------------------
			else if(s == "RIGHT"){								// If the received string equals "RIGHT" turn the robot to the right.
				motor[LeftMotor] = 23;
				motor[RightMotor] = -23;
				wait1Msec(800);
				s = "C";														// Same code as moving left, but now it moves in opposite direction.
			}//---------------------------------------------------------------------------------------------------------------------------
			else if(s == "C" ) {									// If received string equals "C" stop the robot. (this is the break)
				motor[LeftMotor] = 0;
				motor[RightMotor] = 0;							// Both motors are turned off to stop robot from moving.
				stop = true;
				speed = 0;
			}//---------------------------------------------------------------------------------------------------------------------------
			else if(s == "A"){										// If the received string equals "A" execute function: volg_lijn.
				stop = false;
				speed = default_speed;
			}//---------------------------------------------------------------------------------------------------------------------------
		}
		if(motor[motorC] || motor[motorB]){			// If either motor (or both) is turned on, play a sound.
			playSound(soundBlip);           			// Play a sound
		}
		wait1Msec(100);													// Wait 100 miliseconds to receive a new command from app.
	}
	return;
}
