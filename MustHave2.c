#pragma config(Sensor, S1,     SonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     ColorSensor,    sensorColorNxtRED)
#pragma config(Sensor, S3,     LeftSensor,     sensorLightActive)
#pragma config(Motor,  motorB,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)

// Define app variables to send signals over bluetooth to the robot.
const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

// function declarations
void forward(int speed);
void searchLine(int speed, float berekening, float sum);
void slowDownStop();
void stopObstacle();

// global variable definitions
const int default_speed = 16;
int speed = default_speed;
bool stop = true;

// Slow down function so the robot does not stop abruptly
void slowDownStop() {
	for(int i = speed; i > 0; i--) {
		speed--;
		motor[LeftMotor] = speed;
		motor[RightMotor] = speed;
		wait1Msec(50);
	}
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	speed = 0;
	stop = true;
	return;
}

// Slows down and stops in a smooth manner when obstacle is detected
void stopObstacle() {
	if (speed > 0 && stop == false) {
		if(SensorValue(SonarSensor) < 24)
		{
			 slowDownStop();
		}
	}
	return;
}

// function to drive the robot forwards, only gets called if both sensors detect white.
void forward (int speed) {
	motor[RightMotor] = speed;
	motor[LeftMotor] = speed;
	stop = false;
	return;
}

// function to go left or right depending on which of the 2 sensor detects a black line.
void searchLine(int speed, float berekening, float sum) {
	while (true) {
		stopObstacle();  // stop slowly for obstacle if there is an object within range

		if(berekening < 0.5) {
			motor[RightMotor] = speed + (40*berekening);
			motor[LeftMotor] = 0;
		} else if (sum < 0.5){
			motor[RightMotor] = 0;
			motor[LeftMotor] = speed + (40*sum);
		}
		return;
	}
}

task main() {
	// Define variables for the mobile app
	TFileIOResult nBTCmdRdErrorStatus;
	int nSizeOfMessage;
	ubyte nRcvBuffer[kMaxSizeOfMessage];
	string s;

	while (true) {
		int x = SensorValue(LeftSensor);
		int y = SensorValue(ColorSensor);

		float bovenste = x-15;
		float onderste = 72-15;
		float berekening = (bovenste/onderste);

		float up = y-10;
		float down = 53-10;
		float sum = (up/down);

		displayCenteredTextLine(0, "Sonar: %d", SensorValue[SonarSensor]);  	// display Sonar Distance of Obstacle
		displayCenteredTextLine(1, "Color: %d", SensorValue[ColorSensor]);  	// display RGB Value
		displayCenteredTextLine(2, "Light: %d", SensorValue[LeftSensor]);  	// display Light Value
		displayCenteredTextLine(3, "berekening %.2f", berekening);
		displayCenteredTextLine(4, "sum %.2f", sum);

		//wait1Msec(100);  // Wait 100 milliseconds to help display correctly
		stopObstacle();  // Stop slowly for obstacle

		// The robot receives a string that the robot will display.
		nSizeOfMessage = cCmdMessageGetSize(INBOX);

		if (stop == false) {
			forward(speed);

			if (berekening < 0.5 || sum < 0.5) {
				searchLine(speed, berekening, sum);
			}

			if (berekening < 0.5 && sum < 0.5){  // if both sensors are black stop slowly (intersection)
				slowDownStop();  // stop slowly
			}
		}

		if (nSizeOfMessage > kMaxSizeOfMessage){
			nSizeOfMessage = kMaxSizeOfMessage;
		}

		if (nSizeOfMessage > 0){
			nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
			nRcvBuffer[nSizeOfMessage] = '\0';
			s = "";
			stringFromChars(s, (char *) nRcvBuffer);
			displayCenteredBigTextLine(6, s);
			if(s == "UP"){ 											// If received string equals "UP" move robot forward.
				motor[LeftMotor] = 30;
				motor[RightMotor] = 30;						// Turn on both motors with 50% power.
			}//---------------------------------------------------------------------------------------------------------------------------
			if(s == "DOWN"){										// If received string equals "DOWN" move robot backwards.
				motor[LeftMotor] = -30;
				motor[RightMotor] = -30;					// Both motors turn on with 50% power in opposite direction.
			}//-----------------------------------------------------------------------------------------------------------------------
			if(s == "LEFT"){										// If received string equals "LEFT" turn robot to the left.
				motor[LeftMotor] = -23;
				motor[RightMotor] = 23;						// Left motor moves backwards while right motor moves forward at 23% power.
				wait1Msec(800);										// The robot has to turn for a total of 800 miliseconds.
				s = "C";													// Reset string to "C" to stop the robot
			}//---------------------------------------------------------------------------------------------------------------------------
			if(s == "RIGHT"){										// If the received string equals "RIGHT" turn the robot to the right.
				motor[LeftMotor] = 23;
				motor[RightMotor] = -23;
				wait1Msec(800);
				s = "C";													// Same code as moving left, but now it moves in opposite direction.
			}//---------------------------------------------------------------------------------------------------------------------------
			if(s == "C" ) {											// If received string equals "C" stop the robot. (this is the break)
				motor[LeftMotor] = 0;
				motor[RightMotor] = 0;						// Both motors are turned off to stop robot from moving.
				stop = true;
				speed = 0;
			}//---------------------------------------------------------------------------------------------------------------------------
			if(s == "A"){												// If the received string equals "A" execute function: volg_lijn.
				speed = default_speed;
				stop = false;
			}//---------------------------------------------------------------------------------------------------------------------------
			if(stop == true) {
				s = "C";
			}
		}
		if(motor[motorC] || motor[motorB]){		// If either motor (or both) is turned on, play a sound.
			playSound(soundBlip);           		// Play a sound
		}
		wait1Msec(100);												// Wait 100 miliseconds to receive a new command from app.
	}
	return;
}
